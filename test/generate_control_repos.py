# -*- coding: utf-8 -*-
"""
Herein I generate control git repos to perform tests. I want to do this programatically so its auditable. The the standards generation strategy has the following parts.

1. The standards can be programmatically generated.
2. All the methods that generate standards can be called by an automatic test runner like `nose`.
3. Each method in this file will generate one standard set of data (specifically, a git repo). Each git repo will be used to test one or more methods in the main program. The name of the generator method will map to a method in the main program.
4. Tests may use some of the standard data generated by these methods. The test method will explicitly note which standard set of data it is using. In that way I will have a map between a standard set of data, a test, and a method in the main program which is being tested.

For now, the standard data will be put in a directory named `standards`; this directory will be a subdirectory of the `test` directory.

I will need to decide if the standards will be committed to the repository or not.
"""

import git
import tarfile
import os
import shutil


class GeneratorBase():
    """
    Base class for generating standard git repositories for testing.

    Subclasses of this class will be used to generate standard git repos for testing. 
    """
    def __init__():
        pass

    def get_name():
        """
        Returns string with the name of the method this class tests.
        """
        return self.__class__.__name__

    def repo_exists():
        """
        Return bool if a directory of the same name as the repo exists.
        """
        pass


def generate_remove_remotes():
    """
    Generates a git repo with three remotes.
    """
    remotes = {"gethub": "git@gethub.com:username/three_remotes.git",
               "example": "git@example.com:username/three_remotes.git",
               "notaurl": "git@notaurl.com:username/three_remotes.git",}

    repo_dirname = "remove_remotes"

    # Initialize repo.
    repo = git.Repo.init(repo_dirname)

    # Add remotes.
    for name, url in remotes.iteritems():
        repo.create_remote(name, url)


def generate_subdirs_ignored_uncomitted():
    """
    Git repo with one ignored and one uncomitted file, two dirs.

    The two directories will have files which are comitted to the repo. The `.gitignore` will be the uncomitted file, and a file named `ignored` will be ignored in gitignore.
    """
    repo_dirname = "subdirs_ignored_uncomitted"

    # Initialize repo
    repo = git.Repo.init(repo_dirname)

    # Files that will live in the repo.
    gitignore = "ignored"
    ignored_filename = "ignored"
    dir_slug = "dir%s"

    # Make .gitignore
    filepath = os.path.join(repo_dirname, ".gitignore") 
    with open(filepath, "w") as f:
        f.write(gitignore)

    # `touch` file `ignored`
    filepath = os.path.join(repo_dirname, gitignore)
    with open(filepath,"w") as f:
        pass

    # Create the two directories with files.
    for indx in range(1,3):
        dirname = dir_slug % indx
        dirpath = os.path.join(repo_dirname, dirname)

        os.mkdir(dirpath)

        # `touch` file
        file_path = os.path.join(dirpath, "file")
        with open(file_path, "w") as f:
            pass

        # git add file
        add_path = os.path.join(dirname, "file")
        repo.git.add(add_path)

    # Commit changes.
    repo.git.commit(m = "Commit to repo.")
