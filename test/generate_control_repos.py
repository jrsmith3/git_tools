# -*- coding: utf-8 -*-
"""
Herein I generate control git repos to perform tests. I want to do this programatically so its auditable. The the standards generation strategy has the following parts.

1. The standards can be programmatically generated.
2. All the methods that generate standards can be called by an automatic test runner like `nose`.
3. Each method in this file will generate one standard set of data (specifically, a git repo). Each git repo will be used to test one or more methods in the main program. The name of the generator method will map to a method in the main program.
4. Tests may use some of the standard data generated by these methods. The test method will explicitly note which standard set of data it is using. In that way I will have a map between a standard set of data, a test, and a method in the main program which is being tested.

For now, the standard data will be put in a directory named `standards`; this directory will be a subdirectory of the `test` directory.

I will need to decide if the standards will be committed to the repository or not.
"""

import git
import tarfile
import os
import shutil

def generate_repo_with_three_remotes():
    """
    Generates a git repo with three remotes.
    """
    remotes = {"gethub": "git@gethub.com:username/three_remotes.git",
               "example": "git@example.com:username/three_remotes.git",
               "notaurl": "git@notaurl.com:username/three_remotes.git",}

    repo_dirname = "three_remotes"
    repo_targzfilename = repo_dirname + ".tar.gz"

    # Initialize repo.
    repo = git.Repo.init(repo_dirname)

    # Add remotes.
    for name, url in remotes.iteritems():
        repo.create_remote(name, url)

    # Archive repo.
    with tarfile.open(repo_targzfilename, "w:gz") as tar:
        tar.add(repo_dirname)

    # Delete repo directory.
    shutil.rmtree(repo_dirname)

def generate_1_ignore_2_dirs_1_uncommit():
    """
    Repository with one ignored and one uncomitted file, two dirs.

    The two directories will have files which are comitted to the repo. The `.gitignore` will be the uncomitted file, and a file named `ignored` will be ignored in gitignore.
    """
    repo_dirname = "1_ignore_2_dirs_1_uncommit"
    repo_targzfilename = repo_dirname + ".tar.gz"

    # Initialize repo
    repo = git.Repo.init(repo_dirname)

    # Files that will live in the repo.
    gitignore = "ignored"
    ignored_filename = "ignored"
    dir_slug = "dir%s"

    # Make .gitignore
    filepath = os.path.join(repo_dirname, ".gitignore") 
    with open(filepath, "w") as f:
        f.write(gitignore)

    # `touch` file `ignored`
    filepath = os.path.join(repo_dirname, gitignore)
    with open(filepath,"w") as f:
        pass

    # Create the two directories with files.
    for indx in range(1,3):
        dirname = dir_slug % indx
        dirpath = os.path.join(repo_dirname, dirname)

        os.mkdir(dirpath)

        # `touch` file
        file_path = os.path.join(dirpath, "file")
        with open(file_path, "w") as f:
            pass

        # git add file
        add_path = os.path.join(dirname, "file")
        repo.git.add(add_path)

    # Commit changes.
    repo.git.commit(m = "Commit to repo.")

    # Archive repo.
    with tarfile.open(repo_targzfilename, "w:gz") as tar:
        tar.add(repo_dirname)

    # Delete repo directory.
    shutil.rmtree(repo_dirname)
